// Generated by transforming |cwd:///parser/2.7.2.y| on 2016-10-15 at 17:11:42 +0000
%{
  #define YYDEBUG 1
  #include "ast.h"
  #include <functional>
  #include <iostream>
  #include <fstream>
  #include <math.h>
  #include <vector>
  #include <memory>
  #include <cstring>
  #include "except.h"
  #include "parse.tab.h"
	int yylex (void);
	extern int yylineno;
	extern char *yytext;
	void yyerror (char const *);
    // exception list
    std::vector<const char*> except_list;
    std::ofstream ast_out;
    int num_calclist = 0;
    void go(Ast* a)
    {
        if (a)
        {
            try
            {
                ast_out << "digraph ast" << num_calclist++ << " {" << std::endl;
                AstVal* v = a->eval();
                // $1 may be a func definition
                if (v && !v->isFunc())
                    delete v; 
                ast_out << "}" << std::endl;;
                delete a;
            }
            catch (std::exception& e)
            {
                except_list.push_back(e.what());
            }
        }
        // if there are exceptions, print the first and dump all
        if (!except_list.empty())
        {
            std::cout << except_list.front() << std::endl;
            except_list.clear();
        }
    }
%}


%union {
  Ast* ast;
  //behavior
  Ast* (*b) (Ast*, Ast*);
  //unary behavior
  Ast* (*ub) (Ast*);
  //assign behavior
  Ast* (*ab) (AstName*, Ast*);
}

// 83 tokens, in alphabetical order:
%token <ast>  AMPEREQUAL AMPERSAND AND AS ASSERT AT BACKQUOTE BAR BREAK
              CIRCUMFLEX CIRCUMFLEXEQUAL CLASS COLON COMMA CONTINUE DEDENT
              DEF DEL DOT DOUBLESLASH DOUBLESLASHEQUAL 
              DOUBLESTAR DOUBLESTAREQUAL ELIF ELSE ENDMARKER EQEQUAL
              EQUAL EXCEPT EXEC FINALLY FOR FROM GLOBAL GREATER GREATEREQUAL GRLT
              IF IMPORT IN INDENT IS LAMBDA LBRACE LEFTSHIFT LEFTSHIFTEQUAL LESS
              LESSEQUAL LPAR LSQB MINEQUAL MINUS NAME NEWLINE NOT NOTEQUAL 
              NUMBER OR PASS PERCENT PERCENTEQUAL 
              PLUS PLUSEQUAL 
              PRINT RAISE 
              RBRACE RETURN RIGHTSHIFT RIGHTSHIFTEQUAL RPAR RSQB 
              SEMI SLASH SLASHEQUAL STAR STAREQUAL
              STRING TILDE TRY VBAREQUAL WHILE WITH YIELD

%type <ast>  testlist1 file_input pick_NEWLINE_stmt star_NEWLINE_stmt decorator opt_arglist decorators decorated funcdef parameters varargslist opt_EQUAL_test star_fpdef_COMMA opt_DOUBLESTAR_NAME pick_STAR_DOUBLESTAR fpdef fplist stmt simple_stmt small_stmt expr_stmt pick_yield_expr_testlist print_stmt opt_test del_stmt pass_stmt flow_stmt break_stmt continue_stmt return_stmt yield_stmt raise_stmt opt_COMMA_test import_stmt import_name import_from star_DOT plus_DOT pick_STAR_import import_as_name dotted_as_name import_as_names dotted_as_names dotted_name global_stmt exec_stmt assert_stmt compound_stmt if_stmt star_ELIF while_stmt for_stmt try_stmt plus_except opt_ELSE opt_FINALLY with_stmt star_COMMA_with_item with_item except_clause pick_AS_COMMA opt_AS_COMMA suite plus_stmt testlist_safe old_test old_lambdef test opt_IF_ELSE or_test and_test not_test comparison comp_op expr xor_expr and_expr shift_expr pick_LEFTSHIFT_RIGHTSHIFT arith_expr term factor power star_trailer atom pick_yield_expr_testlist_comp opt_yield_test opt_listmaker opt_dictorsetmaker plus_STRING listmaker testlist_comp lambdef trailer subscriptlist subscript opt_test_only opt_sliceop sliceop exprlist testlist dictorsetmaker pick_comp_for pick_for_test classdef opt_testlist arglist argument opt_comp_for list_iter list_for list_if comp_iter comp_for comp_if encoding_decl yield_expr star_fpdef_notest star_COMMA_expr star_COMMA_fpdef star_COMMA_test star_test_COLON_test star_COMMA_subscript star_COMMA_import_as_name plus_COMMA_test plus_COMMA_old_test dictarg listarg arglist_postlist small_stmt_STAR_OR_SEMI
%type <ast> stmt_stmt single_input opt_test_2 opt_test_3
//binary lambda
%type <b>  pick_PLUS_MINUS pick_multop
%type <ab> augassign
//unary lambda
%type <ub> pick_unop
%type <ast> star_EQUAL

%start start
%%

start
	: file_input
	| encoding_decl
    | single_input
	;
//single_input // Used in: start
//	: NEWLINE
//	| simple_stmt
//	| compound_stmt NEWLINE
//	;

single_input // Used in: start
	: NEWLINE
	| stmt_stmt
    ;
file_input // Used in: start
	: star_NEWLINE_stmt ENDMARKER
	;
pick_NEWLINE_stmt // Used in: star_NEWLINE_stmt
	: NEWLINE
	| stmt_stmt
	;

star_NEWLINE_stmt // Used in: file_input, star_NEWLINE_stmt
	: pick_NEWLINE_stmt star_NEWLINE_stmt
	| %empty { $$ = 0; }
	;
decorator // Used in: decorators
	: AT dotted_name LPAR opt_arglist RPAR NEWLINE
	| AT dotted_name NEWLINE
	;
opt_arglist // Used in: decorator, trailer
	: arglist 
	| %empty { $$ = 0; }
	;
decorators // Used in: decorators, decorated
	: decorator decorators
	| decorator
	;
decorated // Used in: compound_stmt
	: decorators classdef
	| decorators funcdef
	;
funcdef // Used in: decorated, compound_stmt
	: DEF NAME parameters COLON suite
    {
        $$ = new AstFuncdef((AstName*)$2, (AstSuite*)$5);
    }
	;
parameters // Used in: funcdef
	: LPAR varargslist RPAR
	| LPAR RPAR
	;
varargslist // Used in: parameters, old_lambdef, lambdef
	: star_fpdef_COMMA pick_STAR_DOUBLESTAR
	| fpdef opt_EQUAL_test star_COMMA_fpdef
	;
opt_EQUAL_test // Used in: varargslist, star_fpdef_COMMA, star_COMMA_fpdef
	: EQUAL test
	| %empty { $$ = 0; }
	;
star_fpdef_COMMA // Used in: varargslist, star_fpdef_COMMA
	: fpdef opt_EQUAL_test COMMA star_fpdef_COMMA
	| %empty { $$ = 0; }
	;
opt_DOUBLESTAR_NAME // Used in: pick_STAR_DOUBLESTAR
	: COMMA DOUBLESTAR NAME
	| %empty { $$ = 0; }
	;
pick_STAR_DOUBLESTAR // Used in: varargslist
	: STAR NAME opt_DOUBLESTAR_NAME
	| DOUBLESTAR NAME
	;
fpdef // Used in: varargslist, star_fpdef_COMMA, fplist, star_fpdef_notest, star_COMMA_fpdef
	: NAME
	| LPAR fplist RPAR
	;
fplist // Used in: fpdef
	: fpdef star_fpdef_notest
	;

stmt_stmt
    : stmt
    { go($1); }

stmt // Used in: pick_NEWLINE_stmt, plus_stmt
	: simple_stmt
	| compound_stmt
	;
simple_stmt // Used in: single_input, stmt, suite
	: small_stmt small_stmt_STAR_OR_SEMI NEWLINE
	;
small_stmt // Used in: simple_stmt, small_stmt_STAR_OR_SEMI
	: expr_stmt { $$ = $1; }
	| print_stmt { $$ = $1; }
	| del_stmt { $$ = 0; }
	| pass_stmt { $$ = 0; }
	| flow_stmt { $$ = $1; }
	| import_stmt { $$ = 0; }
	| global_stmt { $$ = $1; }
	| exec_stmt { $$ = 0; }
	| assert_stmt { $$ = 0; }
	;
expr_stmt // Used in: small_stmt
	: testlist augassign pick_yield_expr_testlist { $$ = $2((AstName*)$1, $3); }
	| testlist star_EQUAL 
    {
        if ($1 && $2)
        {
            $$ = new AstEqual((AstName*)$1, $2);
        }
        else
        {
            $$ = $1;
        }
    }
	;
pick_yield_expr_testlist // Used in: expr_stmt, star_EQUAL
	: yield_expr { }
	| testlist { }
	;
star_EQUAL // Used in: expr_stmt, star_EQUAL
	: EQUAL pick_yield_expr_testlist star_EQUAL { $$ = $2; } 
	| %empty { $$ = 0; }
	;
augassign // Used in: expr_stmt
	: PLUSEQUAL 
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstPlusEqual(x, y) : 0;
            return temp;
        }; 
    }
	| MINEQUAL
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstMinusEqual(x, y) : 0;
            return temp;
        }; 
    }
	| STAREQUAL
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstStarEqual(x, y) : 0;
            return temp;
        }; 
    }
	| SLASHEQUAL
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstDivEqual(x, y) : 0;
            return temp;
        }; 
    }
	| PERCENTEQUAL 
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstModEqual(x, y) : 0;
            return temp;
        }; 
    }
	| AMPEREQUAL { $$ = [](AstName* x, Ast* y) { return (Ast*)NULL; }; }
	| VBAREQUAL { $$ = [](AstName* x, Ast* y) { return (Ast*)NULL; }; }
	| CIRCUMFLEXEQUAL { $$ = [](AstName* x, Ast* y) { return (Ast*)NULL; }; }
	| LEFTSHIFTEQUAL { $$ = [](AstName* x, Ast* y) { return (Ast*)NULL; }; }
	| RIGHTSHIFTEQUAL { $$ = [](AstName* x, Ast* y) { return (Ast*)NULL; }; }
	| DOUBLESTAREQUAL
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstExpEqual(x, y) : 0;
            return temp;
        }; 
    }
	;
	| DOUBLESLASHEQUAL
    { $$ = [](AstName* x, Ast* y) 
        {
            Ast* temp = x && y ? new AstIntDivEqual(x, y) : 0;
            return temp;
        }; 
    }
	;
print_stmt // Used in: small_stmt
	: PRINT opt_test 
    {
        $$ = new AstPrint($2);
    }
	| PRINT RIGHTSHIFT test opt_test_2
	;
opt_test // Used in: print_stmt
	: test star_COMMA_test { $$ = $1; }
	| %empty { $$ = 0; }
	;
opt_test_2 // Used in: print_stmt
	: plus_COMMA_test
	| %empty { $$ = 0; }
	;
del_stmt // Used in: small_stmt
	: DEL exprlist
	;
pass_stmt // Used in: small_stmt
	: PASS
	;
flow_stmt // Used in: small_stmt
	: break_stmt
	| continue_stmt
	| return_stmt { $$ = $1; }
	| raise_stmt
	| yield_stmt
	;
break_stmt // Used in: flow_stmt
	: BREAK
	;
continue_stmt // Used in: flow_stmt
	: CONTINUE
	;
return_stmt // Used in: flow_stmt
	: RETURN testlist
    {
       $$ = new AstReturn($2);
    }
	| RETURN
	;
yield_stmt // Used in: flow_stmt
	: yield_expr
	;
raise_stmt // Used in: flow_stmt
	: RAISE test opt_test_3
	| RAISE
	;
opt_COMMA_test // Used in: opt_test_3, exec_stmt
	: COMMA test
	| %empty { $$ = 0; }
	;
opt_test_3 // Used in: raise_stmt
	: COMMA test opt_COMMA_test
	| %empty { $$ = 0; }
	;
import_stmt // Used in: small_stmt
	: import_name
	| import_from
	;
import_name // Used in: import_stmt
	: IMPORT dotted_as_names
	;
import_from // Used in: import_stmt
	: FROM star_DOT dotted_name IMPORT pick_STAR_import
	| FROM plus_DOT IMPORT pick_STAR_import
	;
star_DOT // Used in: import_from, star_DOT
	: DOT star_DOT
	| %empty { $$ = 0; }
	;
plus_DOT // Used in: import_from, plus_DOT
	: DOT plus_DOT
	| DOT
	;
pick_STAR_import // Used in: import_from
	: STAR
	| LPAR import_as_names RPAR
	| import_as_names
	;
import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: NAME AS NAME
	| NAME
	;
dotted_as_name // Used in: dotted_as_names
	: dotted_name AS NAME
	| dotted_name
	;
import_as_names // Used in: pick_STAR_import
	: import_as_name star_COMMA_import_as_name
	;
dotted_as_names // Used in: import_name, dotted_as_names
	: dotted_as_name
	| dotted_as_names COMMA dotted_as_name
	;
dotted_name // Used in: decorator, import_from, dotted_as_name, dotted_name
	: NAME
	| dotted_name DOT NAME
	;
global_stmt // Used in: small_stmt, global_stmt
	: global_stmt COMMA NAME
    {
        ((AstName*)$1)->makeGlobal();
        $$ = $1;
    }
	| GLOBAL NAME
    {
        ((AstName*)$2)->makeGlobal();
        $$ = $2;
    }
	;
exec_stmt // Used in: small_stmt
	: EXEC expr IN test opt_COMMA_test
	| EXEC expr
	;
assert_stmt // Used in: small_stmt
	: ASSERT test COMMA test
	| ASSERT test
	;
compound_stmt // Used in: single_input, stmt
	: if_stmt { $$ = 0; }
	| while_stmt { $$ = 0; }
	| for_stmt { $$ = 0; }
	| try_stmt { $$ = 0; }
	| with_stmt { $$ = 0; }
	| funcdef { $$ = $1; }
	| classdef { $$ = 0; }
	| decorated { $$ = 0; }
	;
if_stmt // Used in: compound_stmt
	: IF test COLON suite star_ELIF ELSE COLON suite
	| IF test COLON suite star_ELIF
	;
star_ELIF // Used in: if_stmt, star_ELIF
	: ELIF test COLON suite star_ELIF
	| %empty { $$ = 0; }
	;
while_stmt // Used in: compound_stmt
	: WHILE test COLON suite ELSE COLON suite
	| WHILE test COLON suite
	;
for_stmt // Used in: compound_stmt
	: FOR exprlist IN testlist COLON suite ELSE COLON suite
	| FOR exprlist IN testlist COLON suite
	;
try_stmt // Used in: compound_stmt
	: TRY COLON suite plus_except opt_ELSE opt_FINALLY
	| TRY COLON suite FINALLY COLON suite
	;
plus_except // Used in: try_stmt, plus_except
	: except_clause COLON suite plus_except
	| except_clause COLON suite
	;
opt_ELSE // Used in: try_stmt
	: ELSE COLON suite
	| %empty { $$ = 0; }
	;
opt_FINALLY // Used in: try_stmt
	: FINALLY COLON suite
	| %empty { $$ = 0; }
	;
with_stmt // Used in: compound_stmt
	: WITH with_item star_COMMA_with_item COLON suite
	;
star_COMMA_with_item // Used in: with_stmt, star_COMMA_with_item
	: COMMA with_item star_COMMA_with_item
	| %empty { $$ = 0; }
	;
with_item // Used in: with_stmt, star_COMMA_with_item
	: test AS expr
	| test
	;
except_clause // Used in: plus_except
	: EXCEPT test opt_AS_COMMA
	| EXCEPT
	;
pick_AS_COMMA // Used in: opt_AS_COMMA
	: AS
	| COMMA
	;
opt_AS_COMMA // Used in: except_clause
	: pick_AS_COMMA test
	| %empty { $$ = 0; }
	;
suite // Used in: funcdef, if_stmt, star_ELIF, while_stmt, for_stmt, 
      // try_stmt, plus_except, opt_ELSE, opt_FINALLY, with_stmt, classdef
	: simple_stmt
	| NEWLINE INDENT plus_stmt DEDENT
    {
        $$ = $3;
    }
	;
plus_stmt // Used in: suite, plus_stmt
	: stmt plus_stmt
    {

        $$ = new AstSuite($1, (AstSuite*)$2);
    }
	| stmt
    {
        $$ = new AstSuite($1);
    }
	;
testlist_safe // Used in: list_for
	: old_test plus_COMMA_old_test
	| old_test
	;
old_test // Used in: testlist_safe, old_lambdef, list_if, comp_if, plus_COMMA_old_test
	: or_test
	| old_lambdef
	;
old_lambdef // Used in: old_test
	: LAMBDA varargslist COLON old_test
	| LAMBDA COLON old_test
	;
test // Used in: opt_EQUAL_test, print_stmt, opt_test, raise_stmt, 
     // opt_COMMA_test, opt_test_3, exec_stmt, assert_stmt, if_stmt, 
     // star_ELIF, while_stmt, with_item, except_clause, opt_AS_COMMA, 
     // opt_IF_ELSE, listmaker, testlist_comp, lambdef, subscript, 
     // opt_test_only, sliceop, testlist, dictorsetmaker, argument, 
     // testlist1, star_COMMA_test, star_test_COLON_test,
     // plus_COMMA_test, dictarg, listarg
	: or_test opt_IF_ELSE
	| lambdef { $$ = 0; }
	;
opt_IF_ELSE // Used in: test
	: IF or_test ELSE test
	| %empty { $$ = 0; }
	;
or_test // Used in: old_test, test, opt_IF_ELSE, or_test, comp_for
	: and_test
	| or_test OR and_test
	;
and_test // Used in: or_test, and_test
	: not_test
	| and_test AND not_test
	;
not_test // Used in: and_test, not_test
	: NOT not_test
	| comparison { $$ = $1; }
	;
comparison // Used in: not_test, comparison
	: expr { $$ = $1; }
	| comparison comp_op expr { $$ = 0; }
	;
comp_op // Used in: comparison
	: LESS
	| GREATER
	| EQEQUAL
	| GREATEREQUAL
	| LESSEQUAL
	| GRLT
	| NOTEQUAL
	| IN
	| NOT IN
	| IS
	| IS NOT
	;
expr // Used in: exec_stmt, with_item, comparison, expr, 
     // exprlist, star_COMMA_expr
	: xor_expr {  $$ = $1; }
	| expr BAR xor_expr
	;
xor_expr // Used in: expr, xor_expr
	: and_expr { $$ = $1; }
	| xor_expr CIRCUMFLEX and_expr
	;
and_expr // Used in: xor_expr, and_expr
	: shift_expr { $$ = $1; }
	| and_expr AMPERSAND shift_expr
	;
shift_expr // Used in: and_expr, shift_expr
	: arith_expr { $$ = $1; }
	| shift_expr pick_LEFTSHIFT_RIGHTSHIFT arith_expr { $$ = 0; }
	;
pick_LEFTSHIFT_RIGHTSHIFT // Used in: shift_expr
	: LEFTSHIFT
	| RIGHTSHIFT
	;
arith_expr // Used in: shift_expr, arith_expr
	: term
        { $$ = $1; }
	| arith_expr pick_PLUS_MINUS term
        // expect lambda (behavior) and call
        { $$ = $2($1, $3); }
	;
// pass back a lambda to tell you what to do
pick_PLUS_MINUS // Used in: arith_expr
	: PLUS
    { 
        $$ = [](Ast* x, Ast* y) 
        { 
            Ast* temp; 
            if (x && y)
                temp = new AstPlus(x, y);
            else
                temp = 0;
            return temp; 
        }; 
    }
    //{ $$ = [](int x, int y) { return x + y; }; }
	| MINUS
    { 
        $$ = [](Ast* x, Ast* y) 
        {   
            Ast* temp;
            if (x && y)
            {
                temp = new AstMinus(x, y);
            }
            else
            {
                temp = 0;
            }
            return temp;
        }; 
    }
	;
term // Used in: arith_expr, term
	: factor
        { $$ = $1; }
	| term pick_multop factor 
        { $$ = $2($1, $3); }
	;
pick_multop // Used in: term
    // send back lambdas
	: STAR
    { 
        $$ = [](Ast* x, Ast* y) 
        { 
            Ast* temp;
            if (x && y)
            {
                temp  = new AstMult(x, y); 
            }
            else
            {
                temp = 0;
            }
            return temp;
        }; 
    }
    // maybe div by zero, if so generated exception and bail
	| SLASH 
    { $$ = [](Ast* x, Ast* y) 
        { 
            Ast* temp = new AstDiv(x, y); 
            return temp;
        }; 
    }
    ;
	| PERCENT 
    { 
        $$ = [](Ast* x, Ast* y) 
        {
            Ast* temp;
            if (x && y)
            {
                temp = new AstMod(x, y); 
            }
            else
            {
                temp = 0;
            }
            return temp;
        }; 
    }
	| DOUBLESLASH 
    { 
        $$ = [](Ast* x, Ast* y) 
        { 
            Ast* temp = new AstIntDiv(x, y); 
            return temp;
        }; 
    }
	;
factor // Used in: term, factor, power
	: pick_unop factor { $$ = $1($2); }
	| power { $$ = $1; }
	;
pick_unop // Used in: factor
    // lambdarinos 
	: PLUS   
    {
         $$ = [](Ast* x) 
         { 
            Ast* temp = x ? new AstUPlus(x) : 0;
            return temp;
         };
     }
    //{ $$ = [](int x) { return +x; }; }
	| MINUS  
    {
         $$ = [](Ast* x) 
         { 
             Ast* temp = x ? new AstUMin(x) : 0;
             return temp;
         }; 
    }
    //{ return -x; }; }
	| TILDE  
    { 
        $$ = [](Ast* x) 
        { 
            Ast* temp = x ? new AstUNot(x) : 0;
            return temp;
        };
    }
	;
power // Used in: factor
	: atom star_trailer DOUBLESTAR factor { $$ = $1 && $4 ? new AstExp($1, $4) : 0; } 
    | atom star_trailer { $$ = $1; }
	;
star_trailer // Used in: power, star_trailer
	: trailer star_trailer { $$ = 0; }
	| %empty { $$ = 0; }
	;
atom // Used in: power
	: LPAR opt_yield_test RPAR { $$ = $2; }
	| LSQB opt_listmaker RSQB { $$ = 0; }
	| LBRACE opt_dictorsetmaker RBRACE { $$ = 0; }
	| BACKQUOTE testlist1 BACKQUOTE { $$ = 0; }
	| NAME { $$ = $1; }
	| NUMBER { $$ = $1; }
	| plus_STRING { $$ = 0; }
	;

pick_yield_expr_testlist_comp // Used in: opt_yield_test
	: yield_expr { $$ = $1; }
	| testlist_comp { $$ = $1; }
	;
opt_yield_test // Used in: atom
	: pick_yield_expr_testlist_comp { $$ = $1; }
	| %empty { $$ = 0; }
	;
opt_listmaker // Used in: atom
	: listmaker
	| %empty { $$ = 0; }
	;
opt_dictorsetmaker // Used in: atom
	: dictorsetmaker
	| %empty { $$ = 0; }
	;
plus_STRING // Used in: atom, plus_STRING
	: STRING plus_STRING { $$ = $2; }
	| STRING
	;
listmaker // Used in: opt_listmaker
	: test list_for
	| test star_COMMA_test
	;
testlist_comp // Used in: pick_yield_expr_testlist_comp
	: test comp_for
	| test star_COMMA_test
	;
lambdef // Used in: test
	: LAMBDA varargslist COLON test
	| LAMBDA COLON test
	;
trailer // Used in: star_trailer
	: LPAR opt_arglist RPAR
    { $$ = $2; }
	| LSQB subscriptlist RSQB
	| DOT NAME
	;
subscriptlist // Used in: trailer
	: subscript star_COMMA_subscript
	;
subscript // Used in: subscriptlist, star_COMMA_subscript
	: DOT DOT DOT
	| test
	| opt_test_only COLON opt_test_only opt_sliceop
	;
opt_test_only // Used in: subscript
	: test
	| %empty { $$ = 0; }
	;
opt_sliceop // Used in: subscript
	: sliceop
	| %empty { $$ = 0; }
	;
sliceop // Used in: opt_sliceop
	: COLON test
	| COLON
	;
exprlist // Used in: del_stmt, for_stmt, list_for, comp_for
	: expr star_COMMA_expr
	;
testlist // Used in: expr_stmt, pick_yield_expr_testlist, 
         // return_stmt, for_stmt, opt_testlist, yield_expr
	: test star_COMMA_test { $$ = $1; }
	;
dictorsetmaker // Used in: opt_dictorsetmaker
	: test COLON test pick_comp_for
	| test pick_for_test
	;
pick_comp_for // Used in: dictorsetmaker
	: comp_for
	| star_test_COLON_test
	;
pick_for_test // Used in: dictorsetmaker
	: comp_for
	| star_COMMA_test
	;
classdef // Used in: decorated, compound_stmt
	: CLASS NAME LPAR opt_testlist RPAR COLON suite
	| CLASS NAME COLON suite
	;
opt_testlist // Used in: classdef
	: testlist
	| %empty { $$ = 0; }
	;
arglist // Used in: opt_arglist, arglist
	: argument COMMA arglist
	| argument COMMA
	| argument
	| listarg COMMA arglist_postlist
	| listarg
	| dictarg
	;
argument // Used in: arglist, arglist_postlist
	: test opt_comp_for
	| test EQUAL test
	;
opt_comp_for // Used in: argument
	: comp_for
	| %empty { $$ = 0; }
	;
list_iter // Used in: list_for, list_if
	: list_for
	| list_if
	;
list_for // Used in: listmaker, list_iter
	: FOR exprlist IN testlist_safe list_iter
	| FOR exprlist IN testlist_safe
	;
list_if // Used in: list_iter
	: IF old_test list_iter
	| IF old_test
	;
comp_iter // Used in: comp_for, comp_if
	: comp_for
	| comp_if
	;
comp_for // Used in: testlist_comp, pick_comp_for, pick_for_test, 
         // opt_comp_for, comp_iter
	: FOR exprlist IN or_test comp_iter
	| FOR exprlist IN or_test
	;
comp_if // Used in: comp_iter
	: IF old_test comp_iter
	| IF old_test
	;
testlist1 // Used in: atom, testlist1
	: test
	| testlist1 COMMA test
	;
encoding_decl // Used in: start
	: NAME
	;
yield_expr // Used in: pick_yield_expr_testlist, yield_stmt, 
           // pick_yield_expr_testlist_comp
	: YIELD testlist { $$ = $2; }
	| YIELD 
	;
star_fpdef_notest // Used in: fplist, star_fpdef_notest
	: COMMA fpdef star_fpdef_notest
	| COMMA
	| %empty { $$ = 0; }
	;
star_COMMA_expr // Used in: exprlist, star_COMMA_expr
	: COMMA expr star_COMMA_expr
	| COMMA
	| %empty { $$ = 0; }
	;
star_COMMA_fpdef // Used in: varargslist, star_COMMA_fpdef
	: COMMA fpdef opt_EQUAL_test star_COMMA_fpdef
	| COMMA
	| %empty { $$ = 0; }
	;
star_COMMA_test // Used in: opt_test, listmaker, testlist_comp, testlist, pick_for_test, star_COMMA_test
	: COMMA test star_COMMA_test
	| COMMA
	| %empty { $$ = 0; }
	;
star_test_COLON_test // Used in: pick_comp_for, star_test_COLON_test
	: COMMA test COLON test star_test_COLON_test
	| COMMA
	| %empty { $$ = 0; }
	;
star_COMMA_subscript // Used in: subscriptlist, star_COMMA_subscript
	: COMMA subscript star_COMMA_subscript
	| COMMA
	| %empty { $$ = 0; }
	;
star_COMMA_import_as_name // Used in: import_as_names, 
                          // star_COMMA_import_as_name
	: COMMA import_as_name star_COMMA_import_as_name
	| COMMA
	| %empty { $$ = 0; }
	;
plus_COMMA_test // Used in: opt_test_2, plus_COMMA_test
	: COMMA test plus_COMMA_test
	| COMMA test COMMA
	| COMMA test
	;
plus_COMMA_old_test // Used in: testlist_safe, plus_COMMA_old_test
	: COMMA old_test plus_COMMA_old_test
	| COMMA old_test COMMA
	| COMMA old_test
	;
dictarg // Used in: arglist, arglist_postlist
	: DOUBLESTAR test
	;
listarg // Used in: arglist
	: STAR test
	;
arglist_postlist // Used in: arglist, arglist_postlist
	: argument COMMA arglist_postlist
	| dictarg
	| argument
	;
small_stmt_STAR_OR_SEMI // Used in: simple_stmt, small_stmt_STAR_OR_SEMI
	: SEMI small_stmt small_stmt_STAR_OR_SEMI
	| SEMI
	| %empty { $$ = 0; }
	;

%%

#include <stdio.h>
void yyerror (char const *s) {
	fprintf (stderr, "%d: %s with [%s]\n", yylineno, s, yytext);
}

